---
layout: post
title:  "虚拟机总结"
date:   2017-08-04 16:10:54
categories: Java

---

* content
{:toc}

1.内存模型以及分区，详细到每个区放什么？

答： 内存划分为：程序计数器、虚拟机栈、本地方法栈、 Java 堆、方法区；

**程序计数器:** 它可以看作是当前线程所执行的字节码的行号指示器，字节码解释
器通过这个计数器的值来选取下一条需要执行的字节码指令。

**虚拟机栈:** 虚拟机栈为虚拟机执行 java 方法服务，每个方法在执行的同时都会
创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。
每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到
出栈的过程。

**本地方法栈:** 本地方法栈与虚拟机栈所发挥的作用是非常相似的，只不过本地方
法栈为虚拟机执行 native 方法服务。

**Java 堆:** 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都要在
堆上分配。

**方法区:** 存储被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代
码等数据。方法区有一部分叫运行时常量池，这部分内存用来存放编译器生成的
各种字面量和符号引用。

2.堆里面的分区： Eden、 survivor，老年代，各自特点？

答： 根据对象的存活周期的不同，将 Java 堆划分为新生代和老年代。

**新生代:** 新生代中的对象一般存活率低，适合使用复制算法收集，为了提高内存
利用率，将新生代内存分为一个 Eden 区和两个 survivor 区（ HotSpot 虚拟机默认
Eden 区和 survivor 的大小比例为 8:1），每次使用 Eden 区和其中一个 survivor 区
来存对象，当回收时，将 Eden 区和此 survivor 区中存活的对象复制到另一个
survivor 区中，然后清理掉 Eden 区和原来那个 survivor 区中的对象，当存活的对
象过多，超过了 survivor 所能容纳的范围时，此时需要依赖老年代进行分配担保，
将这些对象直接复制到老年代。

**老年代:** 老年代中的对象一般存活率高，一般使用“标记-清除”算法或“标记-
整理-算法”算法进行 GC。老年代的对象中，有一小部分对象是因为在新生代回
收时，老年代做担保进来的，绝大部分对象是因为进行很多次 GC 都没有被回收
而进入老年代的。

3.对象的创建方法，对象的内存分配，对象的访问定位？

答： **对象的创建方法：**

>1、 用 new 语句创建对象；
>
>2、 运用反射手段，调用调用 Java.lang.Class 中的 newInstance()方法；
>
>3、 调用对象的 clone()方法；
>
>4、运用反序列化手段，调用 java.io.ObjectInputStream 对象的 readObject()方法。

**对象的内存分配：**

>为对象分配内存有俩种方式：
>
>一种分配方式是“指针碰撞"，在内存规整的时候，已使用的内存在一侧，未使用
>的内存在一侧时，中间为指示器指针，这个时候的内存分配就是把指示器指针向未使用的区域移动至创建的对象大小相等的距离。
>
>另一种分配方式是“空闲列表”,当内存不规整时，虚拟机必须在不连续的内存空间寻找一块适合对象大小的内存区域，并使用一个列表去维护创建的每一个区域，并更新列表上的记录。

**对象的访问定位：**

java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。目前主流的访问方式有使用句柄和直接指针两种。

>1)如果使用句柄访问方式的话， java 堆会划分出一块内存来作为句柄池，这种时候 java 栈本地变量表中的 reference 中存储的就是对象的句柄地址，而句柄中包含的则是对象的实例数据和对象类型数据的具体地址。
>当我们需要访问一个引用对象时它的访问流程： 是首先到 java 栈的本地变量表中找到 reference，然后通过 reference 指向的句柄地址找到对应的句柄，然后找到对应的实例数据和类型数据。
>
>2)直接指针访问中， reference 中存储的直接是对应于 java 堆中对象的实例数据，实例数据中又划分了一小块内存存储对象的类型数据指针以便可以在方法区内访问到对象的类型数据。

**对象的创建过程：**

1)类的加载检查

每当虚拟机遇到一条 new 指令时，它将先到常量池中检查是否存在将要创建对象的符号引用，并且检查这个符号引用代表的类是否已经加载，解析和初始化过。如果没有， 那必须先加载代表类。

2) 内存分配

就是在 Java 堆中找到一块空闲的内存用来存储该对象信息。

3) 初始化内存空间

对象的内存分配好后接下来就是把这块内存空间都初始化为零。

4) 对象设置

虚拟机要对对象进行必要的设置。 比如对象是那个类的实例，对象的哈希值， gc 分带年龄等，这些信息都存在对象的头之中。

4.判断对象死亡的两种常用算法？

答：**引用计数法：**

给对象添加一个引用计数器，每当有一个地方引用它时，计数器就加 1；当
引用失效时，计数器就减 1；任何时刻计数器为 0 的对象就是死亡的对象。
优点是算法简单，判定效率高。缺点是很难解决对象之间的循环引用问题。

**可达性分析法：**

从 GC Roots 的对象作为起始点，开始向下搜索，当一个对象到 GC Roots 没
有任何引用链相连时，则证明此对象已死亡。

5.GC 的三种收集算法：标记清除算法，复制算法，标记整理算法的原理与特
点，分别在什么地方使用？

答：

标记清除算法：（ 适用于老年代）

首先标记出所有需要回收的对象，在标记完成之后统一回收所有被标记的对象。

缺点：

1)标记和清除两个过程的效率都不高；

2)标记清楚之后会产生大量的不连续的内存碎片。

复制算法：（ 适用于新生代）

将原来的堆内存空间分为两块，每次只使用其中一块，当 GC 时，将存活的对象复制到
另外一块内存空间中，然后清理掉原来那块内块的所有对象。

优点：实现简单，运行效率高。

缺点：空间浪费严重。

标记整理算法：（ 适用于老年代）

首先标记出所有需要回收的对象，然后让所有存活的对象都向一端移动，最后直接清理

掉存活对象边界以外的空间。

优点：不会产生内存碎片。

缺点：成本相对较高，效率也不高。

6.GC 收集器有哪些？它们特点是什么？

答： Serial 收集器（串行收集器）：

这个收集器是单线程收集器，它进行垃圾收集时，必须暂停其他所有的工作
线程，直到它收集结束。 它采用复制算法实现。

Serial Old 收集器：

Serial Old 收集器是 Serial 收集器的老年代版本，它同样是单线程收集器，使
用的是标记整理算法。

ParNew 收集器：

ParNew 收集器是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集
之外，其他行为与 Serial 收集器完全一样。

Parallel Scavenge 收集器（并行清除收集器）：

Parallel Scavenge 收集器是一个新生代收集器，使用复制算法实现，是并行的
多线程收集器。 它关注点是以达到一个可控制的吞吐量为目标。

Parallel Old 收集器：

Parallel Old 收集器是 Parallel Scavenge 收集器的老年代版本，使用多线程和
“标记-整理”算法。

CMS 收集器：

CMS 收集器是一种以获得最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的。

整个过程分为 4 个步骤：初始标记、并发标记、重新标记、并发清除。由于整个过程上耗时最长的并发标记与并发清除过程中，收集器线程可以与
用户线程一起工作，所以总体上说， CMS 收集器的内存回收过程是与用户线程一起并发地执行的。

缺点：

1)CMS 收集器对 CPU 资源非常敏感；

2)无法处理浮动垃圾；

3)CMS 收集器使用“标记-清除”算法，这样会导致出现大量的垃圾碎片。

G1 收集器：

G1 收集器不再划分新生代和老年代了，而是将堆内存划分为多个大小相等的
独立区域。 它可以明确指定停顿时间。它可以有计划的避免在整个 Java 堆中进
行全区域的垃圾收集，它跟踪各个区域里面垃圾回收的价值大小，优先回收价值
最大的区域。

G1 收集器主要分为 4 步： 初始标记、并发标记、 最终标记、筛选回收。

使用“标记-整理” 算法。

7.Minor GC 与 Full GC 分别在什么时候发生？

答： Minor GC ： 发生在新生代中的垃圾收集动作，采用的是复制算法

Full GC： 发生在在老年代的垃圾收集动作，采用的是“标记-清除”算法或
“ 标记-整理”算法，速度一般比 Minor GC 慢 10 倍以上。

8.几种常用的内存调试工具： jmap、 jstack、 jsonsole。

9.类加载的五个过程？

答： 加载：

加载指的是将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。

具体包括以下三个部分：

1)通过类的全类名获取定义此类的二进制字节流；

2)将这些二进制数据流转化为方法区特定的数据结构；

3)创建对应类的 java.lang.Class 对象，作为方法去中这个类的访问接口。

验证：

验证用来确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并
且不会危害虚拟机的自身安全。 主要进行 文件格式验证、元数据验证（ 语义验
证）、字节码验证、符号引用验证。

准备：

准备阶段是为类变量分配内存并设置类变量初始值的阶段，这些变量所使用
的内存都将在方法区中进行分配。

解析：

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

初始化：

初始化阶段是类加载过程的最后一步，到了初始化阶段，才真正执行类中定义的 Java 程序代码。

10.三种系统提供的类加载器和双亲委派模型？

答： 类加载器：

1、 启动类加载：使用 C++实现，是虚拟机自身的一部分。负责将存放在 \lib 目录中的类库加载到虚拟机中，其无法被 Java 程序直接引用。

2、 扩展类加载器：由 ExtClassLoader 实现，负责加载\lib\ext 目录中的类库，开发者可以直接使用。

3、 应用程序类加载器：由 AppClassLoader 实现，负责加载用户类路径ClassPath 上所指定的类库，开发者可以直接使用。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序默认的类
加载器。

双亲委派模型：

双亲委派模型要求除了顶层的启动类加载器外，其余加载器都应当有自己的父类加载器。类加载器之间的父子关系是组合关系而不是继承关系。

工作过程：

如果一个类加载器收到了类加载器请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器完成。每层的类加载器都这样，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自
己无法完成这个加载请求时，子加载器才会尝试自己去加载。

为什么要使用双亲委派模型？

Java 类随着它的类加载器一起具备了一种带优先级的层次关系。比如
java.lang.Object，它存放在 rt.jar 中，无论哪个类加载要加载这个类，最终都会委派给启动类加载器进行加载，因此 Object 类在程序的各个类加载环境中，都是
同一个类。而如果没有使用双亲委派模型，让各个类自己去加载，那么就会产生多个不同的 Object 类，那么 Java 类型体系中最基础的行为也得不到保障，应用程序会变得一片混乱。

11.分派：静态分派与动态分派？

答：

静态分派：

虚拟机在重载时通过参数的静态类型来当判定依据的，而且静态类型在编译期就可知，所以编译器在编译阶段就可根据静态类型来判定究竟使用哪个重载版
本。 Java 中，所有以静态类型来定位方法执行版本的分派动作，都称为静态分派。

动态分派：

变量的实际类型是在运行期确定的，重写方法的调用也是根据实际类型来调用的。 把这种在运行期根据实际类型来确定方法执行版本的分派动作，称为动态分派。